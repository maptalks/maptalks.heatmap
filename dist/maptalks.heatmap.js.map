{"version":3,"file":"maptalks.heatmap.js","sources":["../node_modules/simpleheat/simpleheat.js","../index.js"],"sourcesContent":["'use strict';\n\nif (typeof module !== 'undefined') module.exports = simpleheat;\n\nfunction simpleheat(canvas) {\n    if (!(this instanceof simpleheat)) return new simpleheat(canvas);\n\n    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n    this._ctx = canvas.getContext('2d');\n    this._width = canvas.width;\n    this._height = canvas.height;\n\n    this._max = 1;\n    this._data = [];\n}\n\nsimpleheat.prototype = {\n\n    defaultRadius: 25,\n\n    defaultGradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n    },\n\n    data: function (data) {\n        this._data = data;\n        return this;\n    },\n\n    max: function (max) {\n        this._max = max;\n        return this;\n    },\n\n    add: function (point) {\n        this._data.push(point);\n        return this;\n    },\n\n    clear: function () {\n        this._data = [];\n        return this;\n    },\n\n    radius: function (r, blur) {\n        blur = blur === undefined ? 15 : blur;\n\n        // create a grayscale blurred circle image that we'll use for drawing points\n        var circle = this._circle = this._createCanvas(),\n            ctx = circle.getContext('2d'),\n            r2 = this._r = r + blur;\n\n        circle.width = circle.height = r2 * 2;\n\n        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n        ctx.shadowBlur = blur;\n        ctx.shadowColor = 'black';\n\n        ctx.beginPath();\n        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n\n        return this;\n    },\n\n    resize: function () {\n        this._width = this._canvas.width;\n        this._height = this._canvas.height;\n    },\n\n    gradient: function (grad) {\n        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n        var canvas = this._createCanvas(),\n            ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n        canvas.width = 1;\n        canvas.height = 256;\n\n        for (var i in grad) {\n            gradient.addColorStop(+i, grad[i]);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 1, 256);\n\n        this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n        return this;\n    },\n\n    draw: function (minOpacity) {\n        if (!this._circle) this.radius(this.defaultRadius);\n        if (!this._grad) this.gradient(this.defaultGradient);\n\n        var ctx = this._ctx;\n\n        ctx.clearRect(0, 0, this._width, this._height);\n\n        // draw a grayscale heatmap by putting a blurred circle at each data point\n        for (var i = 0, len = this._data.length, p; i < len; i++) {\n            p = this._data[i];\n            ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);\n            ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n        }\n\n        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n        var colored = ctx.getImageData(0, 0, this._width, this._height);\n        this._colorize(colored.data, this._grad);\n        ctx.putImageData(colored, 0, 0);\n\n        return this;\n    },\n\n    _colorize: function (pixels, gradient) {\n        for (var i = 0, len = pixels.length, j; i < len; i += 4) {\n            j = pixels[i + 3] * 4; // get gradient color from opacity value\n\n            if (j) {\n                pixels[i] = gradient[j];\n                pixels[i + 1] = gradient[j + 1];\n                pixels[i + 2] = gradient[j + 2];\n            }\n        }\n    },\n\n    _createCanvas: function () {\n        if (typeof document !== 'undefined') {\n            return document.createElement('canvas');\n        } else {\n            // create a new canvas instance in node.js\n            // the canvas class needs to have a default constructor without any parameter\n            return new this._canvas.constructor();\n        }\n    }\n};\n","import * as maptalks from 'maptalks';\nimport simpleheat from 'simpleheat';\nimport { reshader, CanvasCompatible } from '@maptalks/gl';\nimport vert from './glsl/points.vert';\nimport frag from './glsl/points.frag';\nimport gradientVert from './glsl/gradient.vert';\nimport gradientFrag from './glsl/gradient.frag';\n\nimport wgslVert from './wgsl/points_vert.wgsl';\nimport wgslFrag from './wgsl/points_frag.wgsl';\nimport wgslGradientVert from './wgsl/gradient_vert.wgsl';\nimport wgslGradientFrag from './wgsl/gradient_frag.wgsl';\n\nconst options = {\n    'max': 1,\n    'gradient': {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n    },\n    'radius': 25,\n    'blur': 15,\n    'heatValueScale': 1,\n    'minOpacity': 0.05,\n    'hitDetect': false\n};\n\nconst COORD = new maptalks.Coordinate(0, 0);\nconst POINT = new maptalks.Point(0, 0);\n\nexport class HeatLayer extends maptalks.Layer {\n\n    constructor(id, heats, options) {\n        if (!Array.isArray(heats)) {\n            options = heats;\n            heats = null;\n        }\n        super(id, options);\n        this._heats = heats || [];\n    }\n\n    getData() {\n        return this._heats;\n    }\n\n    setData(heats) {\n        this._heats = heats || [];\n        return this._resetData();\n    }\n\n    addPoint(heat) {\n        if (!heat) {\n            return this;\n        }\n        if (heat[0] && Array.isArray(heat[0])) {\n            maptalks.Util.pushIn(this._heats, heat);\n        } else {\n            this._heats.push(heat);\n        }\n        return this._update(heat);\n    }\n\n    onConfig(conf) {\n        for (const p in conf) {\n            if (p === 'gradient') {\n                this._updateGradient();\n                return this;\n            }\n        }\n        return this;\n    }\n\n    _updateGradient() {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            renderer.updateGradient();\n            renderer.setToRedraw();\n        }\n        return this;\n    }\n\n    _resetData() {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            renderer.resetData();\n            renderer.setToRedraw();\n        }\n        return this;\n    }\n\n    _update(point) {\n        const renderer = this._getRenderer();\n        if (renderer) {\n            renderer.updateData(point);\n            renderer.setToRedraw();\n        }\n    }\n\n    isEmpty() {\n        if (!this._heats.length) {\n            return true;\n        }\n        return false;\n    }\n\n    clear() {\n        this._heats = [];\n        this._resetData();\n        this.fire('clear');\n        return this;\n    }\n\n    /**\n     * Export the HeatLayer's JSON.\n     * @return {Object} layer's JSON\n     */\n    toJSON(options) {\n        if (!options) {\n            options = {};\n        }\n        const json = {\n            'type': this.getJSONType(),\n            'id': this.getId(),\n            'options': this.config()\n        };\n        const data = this.getData();\n        if (options['clipExtent']) {\n            let clipExtent = new maptalks.Extent(options['clipExtent']);\n            const r = this._getHeatRadius();\n            if (r) {\n                clipExtent = clipExtent._expand(r);\n            }\n            const clipped = [];\n            for (let i = 0, len = data.length; i < len; i++) {\n                if (clipExtent.contains(new maptalks.Coordinate(data[i][0], data[i][1]))) {\n                    clipped.push(data[i]);\n                }\n            }\n            json['data'] = clipped;\n        } else {\n            json['data'] = data;\n        }\n\n        return json;\n    }\n\n    /**\n     * Reproduce a HeatLayer from layer's JSON.\n     * @param  {Object} json - layer's JSON\n     * @return {maptalks.HeatLayer}\n     * @static\n     * @private\n     * @function\n     */\n    static fromJSON(json) {\n        if (!json || json['type'] !== 'HeatLayer') { return null; }\n        return new HeatLayer(json['id'], json['data'], json['options']);\n    }\n\n\n    _getHeatRadius() {\n        if (!this._getRenderer()) {\n            return null;\n        }\n        return this._getRenderer()._heatRadius;\n    }\n}\n\nHeatLayer.mergeOptions(options);\n\nHeatLayer.registerJSONType('HeatLayer');\n\nHeatLayer.registerRenderer('canvas', class extends maptalks.renderer.CanvasRenderer {\n\n    draw() {\n        const map = this.getMap(),\n            layer = this.layer,\n            extent = map.getContainerExtent();\n        let maskExtent = this.prepareCanvas(),\n            displayExtent = extent;\n        if (maskExtent) {\n            maskExtent = maskExtent.convertTo(c => map._pointToContainerPoint(c));\n            //out of layer mask\n            if (!maskExtent.intersects(extent)) {\n                this.completeRender();\n                return;\n            }\n            displayExtent = extent.intersection(maskExtent);\n        }\n\n        if (!this._heater) {\n            this._heater = simpleheat(this.canvas);\n        }\n        this._heater.radius(layer.options['radius'] || this._heater.defaultRadius, layer.options['blur']);\n        if (layer.options['gradient']) {\n            this._heater.gradient(layer.options['gradient']);\n        }\n        this._heater.max(layer.options['max']);\n        //a cache of heat points' viewpoints.\n        if (!this._heatViews) {\n            this._heatViews = [];\n        }\n\n        const heats = layer.getData();\n        if (heats.length === 0) {\n            this.completeRender();\n            return;\n        }\n        //fix https://github.com/maptalks/maptalks.heatmap/issues/55\n        if (this._heater) {\n            const width = this._heater._width, height = this._heater._height;\n            if (Math.min(width, height) <= 0) {\n                this.completeRender();\n                return;\n            }\n        }\n        const data = this._heatData(heats, displayExtent);\n        this._heater.data(data).draw(layer.options['minOpacity']);\n        this.completeRender();\n    }\n\n    drawOnInteracting() {\n        this.draw();\n    }\n\n    _heatData(heats, displayExtent) {\n        const map = this.getMap(),\n            layer = this.layer;\n        const projection = map.getProjection();\n        const data = [],\n            r = this._heater._r,\n            max = layer.options['max'] === undefined ? 1 : layer.options['max'],\n            cellSize = r / 2,\n            grid = [],\n            panePos = map.offsetPlatform(),\n            offsetX = Math.abs(panePos.x) % cellSize,\n            offsetY = Math.abs(panePos.y) % cellSize;\n        let heat, p, cell, x, y, k;\n        // displayExtent = displayExtent.expand(r).convertTo(c => new maptalks.Point(map._containerPointToPrj(c)));\n        const { xmin, ymin, xmax, ymax } = displayExtent.expand(r);\n        this._heatRadius = r;\n        const coord = new maptalks.Coordinate(0, 0);\n        for (let i = 0, l = heats.length; i < l; i++) {\n            heat = heats[i];\n            if (!this._heatViews[i]) {\n                this._heatViews[i] = projection.project(coord.set(heat[0], heat[1]));\n            }\n            p = this._heatViews[i];\n            //fix https://github.com/maptalks/maptalks.heatmap/issues/54\n            // if (displayExtent.contains(p)) {\n            p = map._prjToContainerPoint(p);\n            if (p.x < xmin || p.x > xmax || p.y < ymin || p.y > ymax) {\n                continue;\n            }\n            x = Math.floor((p.x - offsetX) / cellSize) + 2;\n            y = Math.floor((p.y - offsetY) / cellSize) + 2;\n\n            k = (heat[2] !== undefined ? +heat[2] : 0.1) * layer.options['heatValueScale'];\n\n            grid[y] = grid[y] || [];\n            cell = grid[y][x];\n\n            if (!cell) {\n                grid[y][x] = [p.x, p.y, k];\n\n            } else {\n                cell[0] = (cell[0] * cell[2] + (p.x) * k) / (cell[2] + k); // x\n                cell[1] = (cell[1] * cell[2] + (p.y) * k) / (cell[2] + k); // y\n                cell[2] += k; // cumulated intensity value\n            }\n            // }\n        }\n        for (let i = 0, l = grid.length; i < l; i++) {\n            if (grid[i] && grid[i].length) {\n                for (let j = 0, ll = grid[i].length; j < ll; j++) {\n                    cell = grid[i][j];\n                    if (cell) {\n                        data.push([\n                            Math.round(cell[0]),\n                            Math.round(cell[1]),\n                            Math.min(cell[2], max)\n                        ]);\n                    }\n                }\n            }\n        }\n        return data;\n    }\n\n    onZoomEnd() {\n        delete this._heatViews;\n        super.onZoomEnd.apply(this, arguments);\n    }\n\n    onResize() {\n        super.onResize.apply(this, arguments);\n        if (this.canvas) {\n            this._heater._width = this.canvas.width;\n            this._heater._height = this.canvas.height;\n        }\n    }\n\n    onRemove() {\n        this.clearHeatCache();\n        delete this._heater;\n    }\n\n    updateData() {\n    }\n\n    resetData() {\n        this.clearHeatCache();\n    }\n\n    updateGradient() {\n    }\n\n    clearHeatCache() {\n        delete this._heatViews;\n    }\n});\n\nif (typeof CanvasCompatible !== 'undefined') {\n    const HeatLayerGLRenderer = class extends CanvasCompatible(maptalks.renderer.LayerAbstractRenderer) {\n        drawOnInteracting(event, timestamp, parentContext) {\n            this.draw(timestamp, parentContext);\n        }\n\n        draw(timestamp, parentContext) {\n            this.prepareCanvas();\n            if (!this._renderer) {\n                return;\n            }\n            const heats = this.layer.getData();\n            if (heats.length !== this.pointCount) {\n                for (let i = this.pointCount; i < heats.length; i++) {\n                    this.addPoint(...heats[i]);\n                }\n                this._updateGeometryData();\n            }\n            const fbo = parentContext && parentContext.renderTarget && context.renderTarget.fbo;\n            this._clearFBO();\n            this._geometry.setDrawCount(this.pointCount * 6);\n            const map = this.getMap();\n            const glRes = map.getGLRes();\n            const uniforms = {\n                zoomScale: map.getResolution() / glRes,\n                projViewModelMatrix: map.projViewMatrix\n            };\n            this._renderer.render(this._pointShader, uniforms, this._scene, this._fbo);\n            this._renderer.render(this._gradientShader, null, this._gradientScene, fbo);\n        }\n\n        updateData(point) {\n            this.addPoint(point[0], point[1], point[2]);\n        }\n\n        _clearFBO() {\n            this.device.clear({\n                color: [0, 0, 0, 0],\n                depth: 1,\n                framebuffer: this._fbo\n            });\n        }\n\n        clearHeatCache() {\n\n        }\n\n        resetData() {\n            this._reset();\n        }\n\n        updateGradient() {\n            this._initGradient();\n        }\n\n        clear() {\n            this._reset();\n            super.clear();\n        }\n\n        _reset() {\n            this.pointCount = 0;\n            this.bufferIndex = 0;\n            this.offsetIndex = 0;\n            this.intensityIndex = 0;\n        }\n\n        initContext() {\n            this._initData();\n            this._initMesh();\n            this._initGradient();\n            const viewport = {\n                x : 0,\n                y : 0,\n                width : () => {\n                    return this.canvas ? this.canvas.width : 1;\n                },\n                height : () => {\n                    return this.canvas ? this.canvas.height : 1;\n                }\n            };\n            const extraCommandProps = {\n                blend: {\n                    enable: true,\n                    func: {\n                        dst: 1,\n                        src: 1\n                    }\n                },\n                depth: {\n                    enable: false,\n                },\n                viewport\n            }\n            this._pointShader = new reshader.MeshShader({\n                name: 'heatmap-point',\n                vert,\n                frag,\n                wgslVert,\n                wgslFrag,\n                extraCommandProps\n            });\n\n            this._gradientShader = new reshader.MeshShader({\n                name: 'heatmap-gradient',\n                vert: gradientVert,\n                frag: gradientFrag,\n                wgslVert: wgslGradientVert,\n                wgslFrag: wgslGradientFrag,\n                extraCommandProps: {\n                    blend: {\n                        enable: true,\n                        func: {\n                            src: 1,\n                            dst: 'one minus src alpha'\n                        }\n                    },\n                    depth: {\n                        enable: false,\n                    },\n                    viewport\n                }\n            });\n        }\n\n        _initData() {\n            this.bufferIndex = 0;\n            this.offsetIndex = 0;\n            this.intensityIndex = 0;\n            this.pointCount = 0;\n            this.maxPointCount = 1024 * 10;\n\n            const { positionBufferData, offsetBufferData, intensityBufferData } = this._initBuffers();\n            this.positionBufferData = positionBufferData;\n            this.offsetBufferData = offsetBufferData;\n            this.intensityBufferData = intensityBufferData;\n        }\n\n        _initBuffers() {\n            const map = this.getMap();\n            const isWebGPU = map.getRenderer().isWebGPU();\n            const vertexSize = 2;\n            const offsetSize = 2;\n            const intensitySize = 1;\n            const positionBufferData = new Float32Array(\n                this.maxPointCount * vertexSize * 6\n            );\n            const offsetBufferData = new Float32Array(\n                this.maxPointCount * offsetSize * 6\n            );\n            const intensityBufferData = isWebGPU ? new Float32Array(\n                this.maxPointCount * intensitySize * 6\n            ) : new Uint8Array(\n                this.maxPointCount * intensitySize * 6\n            );\n            return { positionBufferData, offsetBufferData, intensityBufferData };\n        }\n\n        _initMesh() {\n            this._renderer = new reshader.Renderer(this.device);\n            this._geometry = new reshader.Geometry(\n                {\n                    aPosition: this.positionBufferData,\n                    aOffset: this.offsetBufferData,\n                    aIntensity: this.intensityBufferData\n                },\n                null,\n                this.pointCount * 6,\n                {\n                    positionSize: 2\n                }\n            );\n            this._geometry.generateBuffers(this.device);\n            this._mesh = new reshader.Mesh(this._geometry);\n            this._scene = new reshader.Scene([this._mesh]);\n            const canvas = this.canvas;\n            const color = this.device.texture({\n                type: 'float16',\n                min: 'nearest',\n                mag: 'nearest',\n                width: canvas.width,\n                height: canvas.height\n            });\n            this._fbo = this.device.framebuffer({\n                width: canvas.width,\n                height: canvas.height,\n                colors: [color],\n                colorFormat: 'rgba',\n                depthStencil: false\n            });\n\n            const quad = new Int8Array([\n                -1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 1\n            ]);\n            this._gradientGeometry = new reshader.Geometry(\n                {\n                    aPosition: quad\n                },\n                null,\n                0,\n                {\n                    positionSize: 4\n                }\n            );\n            this._gradientGeometry.generateBuffers(this.device);\n            this._gradientMesh = new reshader.Mesh(this._gradientGeometry);\n            this._gradientScene = new reshader.Scene([this._gradientMesh]);\n        }\n\n        _initGradient() {\n            const gradientData = gradient(this.layer.options['gradient']);\n            if (this._gradientTexture) {\n                if (this._gradientTexture.update) {\n                    this._gradientTexture.update(gradientData);\n                } else {\n                    this._gradientTexture(gradientData);\n                }\n            } else {\n                this._gradientTexture = this.device.texture(gradientData);\n            }\n            this._gradientMesh.setUniform('source', this._fbo);\n        }\n\n        addVertex(x, y, xs, ys, intensity) {\n            const map = this.getMap();\n            const glRes = map.getGLRes();\n            COORD.set(x, y);\n            const point = map.coordToPointAtRes(COORD, glRes, POINT);\n            x = point.x;\n            y = point.y;\n            this.positionBufferData[this.bufferIndex++] = x;\n            this.positionBufferData[this.bufferIndex++] = y;\n            this.offsetBufferData[this.offsetIndex++] = xs;\n            this.offsetBufferData[this.offsetIndex++] = ys;\n            this.intensityBufferData[this.intensityIndex++] = intensity * 255;\n        }\n\n        addPoint(x, y, intensity) {\n            const size = this.layer.options['radius'] || 25;\n            if (intensity == null) {\n                intensity = 0.2;\n            }\n            const max = this.layer.options['max'] || 1;\n            intensity /= max;\n            this._check();\n            const s = size;\n            this.addVertex(x, y, -s, -s, intensity);\n            this.addVertex(x, y, +s, -s, intensity);\n            this.addVertex(x, y, -s, +s, intensity);\n            this.addVertex(x, y, -s, +s, intensity);\n            this.addVertex(x, y, +s, -s, intensity);\n            this.addVertex(x, y, +s, +s, intensity);\n            return (this.pointCount += 1);\n        }\n\n        _check() {\n            if (this.pointCount >= this.maxPointCount - 1) {\n                this.maxPointCount += 1024 * 10;\n                const { positionBufferData, offsetBufferData, intensityBufferData } = this._initBuffers();\n                for (let i = 0; i < this.bufferIndex; i++) {\n                    positionBufferData[i] = this.positionBufferData[i];\n                    offsetBufferData[i] = this.offsetBufferData[i];\n                }\n                for (let i = 0; i < this.intensityIndex; i++) {\n                    intensityBufferData[i] = this.intensityBufferData[i];\n                }\n                this.positionBufferData = positionBufferData;\n                this.offsetBufferData = offsetBufferData;\n                this.intensityBufferData = intensityBufferData;\n                this._updateGeometryData();\n            }\n        }\n\n        _updateGeometryData() {\n            this._geometry.updateData('aPosition', this.positionBufferData);\n            this._geometry.updateData('aOffset', this.offsetBufferData);\n            this._geometry.updateData('aIntensity', this.intensityBufferData);\n        }\n\n        onResize(params) {\n            if (this._fbo && this.canvas) {\n                const canvas = this.canvas;\n                if (this._fbo.width !== canvas.width || this._fbo.height !== canvas.height) {\n                    this._fbo.resize(canvas.width, canvas.height);\n                }\n            }\n            super.onResize(params);\n        }\n\n        onRemove() {\n            this._reset();\n            if (this._pointShader) {\n                this._pointShader.dispose();\n                delete this._pointShader;\n            }\n            if (this._gradientShader) {\n                this._gradientShader.dispose();\n                delete this._gradientShader;\n            }\n            if (this._gradientTexture) {\n                this._gradientTexture.destroy();\n                delete this._gradientTexture;\n            }\n            if (this._mesh) {\n                this._mesh.dispose();\n                delete this._mesh;\n            }\n            if (this._geometry) {\n                this._geometry.dispose();\n                delete this._geometry;\n            }\n            if (this._fbo) {\n                this._fbo.destroy();\n                delete this._fbo;\n            }\n            if (this._gradientMesh) {\n                this._gradientMesh.dispose();\n                delete this._gradientMesh;\n            }\n            if (this._gradientGeometry) {\n                this._gradientGeometry.dispose();\n                delete this._gradientGeometry;\n            }\n            delete this.positionBufferData;\n            delete this.offsetBufferData;\n            delete this.intensityBufferData;\n            delete this._renderer;\n            delete this._scene;\n            delete this._gradientScene;\n            super.onRemove();\n        }\n    };\n    HeatLayer.registerRenderer('gl', HeatLayerGLRenderer);\n    HeatLayer.registerRenderer('gpu', HeatLayerGLRenderer);\n}\n\nfunction gradient(grad) {\n    // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n    const canvas = document.createElement('canvas'),\n        ctx = canvas.getContext('2d', {willReadFrequently: true}),\n        gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n    canvas.width = 256;\n    canvas.height = 1;\n\n    for (const i in grad) {\n        gradient.addColorStop(+i, grad[i]);\n    }\n\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, 1, 256);\n\n    return {\n        data: ctx.getImageData(0, 0, 1, 256).data,\n        width: canvas.width,\n        height: canvas.height\n    };\n}\n"],"names":["simpleheat","canvas","this","_canvas","document","getElementById","_ctx","getContext","_width","width","_height","height","_max","_data","module","exports","prototype","defaultRadius","defaultGradient","data","max","add","point","push","clear","radius","r","blur","undefined","circle","_circle","_createCanvas","ctx","r2","_r","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","beginPath","arc","Math","PI","closePath","fill","resize","gradient","grad","createLinearGradient","i","addColorStop","fillStyle","fillRect","_grad","getImageData","draw","minOpacity","clearRect","p","len","length","globalAlpha","drawImage","colored","_colorize","putImageData","pixels","j","createElement","constructor","COORD","maptalks","Coordinate","POINT","Point","HeatLayer","Layer","id","heats","options","Array","isArray","super","_heats","getData","setData","_resetData","addPoint","heat","Util","pushIn","_update","onConfig","conf","_updateGradient","renderer","_getRenderer","updateGradient","setToRedraw","resetData","updateData","isEmpty","fire","toJSON","json","type","getJSONType","getId","config","clipExtent","Extent","_getHeatRadius","_expand","clipped","contains","static","_heatRadius","mergeOptions","heatValueScale","hitDetect","registerJSONType","registerRenderer","CanvasRenderer","map","getMap","layer","extent","getContainerExtent","maskExtent","prepareCanvas","displayExtent","convertTo","c","_pointToContainerPoint","intersects","completeRender","intersection","_heater","_heatViews","min","_heatData","drawOnInteracting","projection","getProjection","cellSize","grid","panePos","offsetPlatform","offsetX","abs","x","offsetY","y","cell","k","xmin","ymin","xmax","ymax","expand","coord","l","project","set","_prjToContainerPoint","floor","ll","round","onZoomEnd","apply","arguments","onResize","onRemove","clearHeatCache","CanvasCompatible","HeatLayerGLRenderer","LayerAbstractRenderer","event","timestamp","parentContext","_renderer","pointCount","_updateGeometryData","fbo","renderTarget","context","_clearFBO","_geometry","setDrawCount","glRes","getGLRes","uniforms","zoomScale","getResolution","projViewModelMatrix","projViewMatrix","render","_pointShader","_scene","_fbo","_gradientShader","_gradientScene","device","color","depth","framebuffer","_reset","_initGradient","bufferIndex","offsetIndex","intensityIndex","initContext","_initData","_initMesh","viewport","extraCommandProps","blend","enable","func","dst","src","reshader","MeshShader","name","vert","frag","wgslVert","wgslFrag","maxPointCount","positionBufferData","offsetBufferData","intensityBufferData","_initBuffers","isWebGPU","getRenderer","Float32Array","Uint8Array","Renderer","Geometry","aPosition","aOffset","aIntensity","positionSize","generateBuffers","_mesh","Mesh","Scene","texture","mag","colors","colorFormat","depthStencil","quad","Int8Array","_gradientGeometry","_gradientMesh","gradientData","willReadFrequently","_gradientTexture","update","setUniform","addVertex","xs","ys","intensity","coordToPointAtRes","size","_check","s","params","dispose","destroy"],"mappings":"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"}