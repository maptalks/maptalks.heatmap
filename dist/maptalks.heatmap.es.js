/*!
 * maptalks.heatmap v0.7.0
 * LICENSE : MIT
 * (c) 2016-2025 maptalks.org
 */
import*as t from"maptalks";import{CanvasCompatible as e,reshader as i}from"@maptalks/gl";var n={exports:{}};!function(t){function e(t){if(!(this instanceof e))return new e(t);this._canvas=t="string"==typeof t?document.getElementById(t):t,this._ctx=t.getContext("2d"),this._width=t.width,this._height=t.height,this._max=1,this._data=[]}n.exports=e,e.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(t){return this._data=t,this},max:function(t){return this._max=t,this},add:function(t){return this._data.push(t),this},clear:function(){return this._data=[],this},radius:function(t,e){e=void 0===e?15:e;var i=this._circle=this._createCanvas(),n=i.getContext("2d"),a=this._r=t+e;return i.width=i.height=2*a,n.shadowOffsetX=n.shadowOffsetY=2*a,n.shadowBlur=e,n.shadowColor="black",n.beginPath(),n.arc(-a,-a,t,0,2*Math.PI,!0),n.closePath(),n.fill(),this},resize:function(){this._width=this._canvas.width,this._height=this._canvas.height},gradient:function(t){var e=this._createCanvas(),i=e.getContext("2d"),n=i.createLinearGradient(0,0,0,256);for(var a in e.width=1,e.height=256,t)n.addColorStop(+a,t[a]);return i.fillStyle=n,i.fillRect(0,0,1,256),this._grad=i.getImageData(0,0,1,256).data,this},draw:function(t){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var e=this._ctx;e.clearRect(0,0,this._width,this._height);for(var i,n=0,a=this._data.length;n<a;n++)i=this._data[n],e.globalAlpha=Math.max(i[2]/this._max,void 0===t?.05:t),e.drawImage(this._circle,i[0]-this._r,i[1]-this._r);var s=e.getImageData(0,0,this._width,this._height);return this._colorize(s.data,this._grad),e.putImageData(s,0,0),this},_colorize:function(t,e){for(var i,n=0,a=t.length;n<a;n+=4)(i=4*t[n+3])&&(t[n]=e[i],t[n+1]=e[i+1],t[n+2]=e[i+2])},_createCanvas:function(){return"undefined"!=typeof document?document.createElement("canvas"):new this._canvas.constructor}}}();var a=n.exports;const s=new t.Coordinate(0,0),r=new t.Point(0,0);class o extends t.Layer{constructor(t,e,i){Array.isArray(e)||(i=e,e=null),super(t,i),this._heats=e||[]}getData(){return this._heats}setData(t){return this._heats=t||[],this._resetData()}addPoint(e){return e?(e[0]&&Array.isArray(e[0])?t.Util.pushIn(this._heats,e):this._heats.push(e),this._update(e)):this}onConfig(t){for(const e in t)if("gradient"===e)return this._updateGradient(),this;return this}_updateGradient(){const t=this._getRenderer();return t&&(t.updateGradient(),t.setToRedraw()),this}_resetData(){const t=this._getRenderer();return t&&(t.resetData(),t.setToRedraw()),this}_update(t){const e=this._getRenderer();e&&(e.updateData(t),e.setToRedraw())}isEmpty(){return!this._heats.length}clear(){return this._heats=[],this._resetData(),this.fire("clear"),this}toJSON(e){e||(e={});const i={"type":this.getJSONType(),"id":this.getId(),"options":this.config()},n=this.getData();if(e.clipExtent){let a=new t.Extent(e.clipExtent);const s=this._getHeatRadius();s&&(a=a._expand(s));const r=[];for(let e=0,i=n.length;e<i;e++)a.contains(new t.Coordinate(n[e][0],n[e][1]))&&r.push(n[e]);i.data=r}else i.data=n;return i}static fromJSON(t){return t&&"HeatLayer"===t.type?new o(t.id,t.data,t.options):null}_getHeatRadius(){return this._getRenderer()?this._getRenderer()._heatRadius:null}}if(o.mergeOptions({"max":1,"gradient":{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},"radius":25,"blur":15,"heatValueScale":1,"minOpacity":.05,"hitDetect":!1}),o.registerJSONType("HeatLayer"),o.registerRenderer("canvas",class extends t.renderer.CanvasRenderer{draw(){const t=this.getMap(),e=this.layer,i=t.getContainerExtent();let n=this.prepareCanvas(),s=i;if(n){if(n=n.convertTo((e=>t._pointToContainerPoint(e))),!n.intersects(i))return void this.completeRender();s=i.intersection(n)}this._heater||(this._heater=a(this.canvas)),this._heater.radius(e.options.radius||this._heater.defaultRadius,e.options.blur),e.options.gradient&&this._heater.gradient(e.options.gradient),this._heater.max(e.options.max),this._heatViews||(this._heatViews=[]);const r=e.getData();if(0===r.length)return void this.completeRender();if(this._heater){const t=this._heater._width,e=this._heater._height;if(Math.min(t,e)<=0)return void this.completeRender()}const o=this._heatData(r,s);this._heater.data(o).draw(e.options.minOpacity),this.completeRender()}drawOnInteracting(){this.draw()}_heatData(e,i){const n=this.getMap(),a=this.layer,s=n.getProjection(),r=[],o=this._heater._r,h=void 0===a.options.max?1:a.options.max,f=o/2,d=[],l=n.offsetPlatform(),u=Math.abs(l.x)%f,c=Math.abs(l.y)%f;let p,g,_,m,v,y;const{xmin:x,ymin:w,xmax:D,ymax:b}=i.expand(o);this._heatRadius=o;const I=new t.Coordinate(0,0);for(let t=0,i=e.length;t<i;t++)p=e[t],this._heatViews[t]||(this._heatViews[t]=s.project(I.set(p[0],p[1]))),g=this._heatViews[t],g=n._prjToContainerPoint(g),g.x<x||g.x>D||g.y<w||g.y>b||(m=Math.floor((g.x-u)/f)+2,v=Math.floor((g.y-c)/f)+2,y=(void 0!==p[2]?+p[2]:.1)*a.options.heatValueScale,d[v]=d[v]||[],_=d[v][m],_?(_[0]=(_[0]*_[2]+g.x*y)/(_[2]+y),_[1]=(_[1]*_[2]+g.y*y)/(_[2]+y),_[2]+=y):d[v][m]=[g.x,g.y,y]);for(let t=0,e=d.length;t<e;t++)if(d[t]&&d[t].length)for(let e=0,i=d[t].length;e<i;e++)_=d[t][e],_&&r.push([Math.round(_[0]),Math.round(_[1]),Math.min(_[2],h)]);return r}onZoomEnd(){delete this._heatViews,super.onZoomEnd.apply(this,arguments)}onResize(){super.onResize.apply(this,arguments),this.canvas&&(this._heater._width=this.canvas.width,this._heater._height=this.canvas.height)}onRemove(){this.clearHeatCache(),delete this._heater}updateData(){}resetData(){this.clearHeatCache()}updateGradient(){}clearHeatCache(){delete this._heatViews}}),void 0!==e){const n=class extends(e(t.renderer.LayerAbstractRenderer)){drawOnInteracting(t,e,i){this.draw(e,i)}draw(t,e){if(this.prepareCanvas(),!this._renderer)return;const i=this.layer.getData();if(i.length!==this.pointCount){for(let t=this.pointCount;t<i.length;t++)this.addPoint(...i[t]);this._updateGeometryData()}const n=e&&e.renderTarget&&context.renderTarget.fbo;this._clearFBO(),this._geometry.setDrawCount(6*this.pointCount);const a=this.getMap(),s=a.getGLRes(),r={zoomScale:a.getResolution()/s,projViewModelMatrix:a.projViewMatrix};this._renderer.render(this._pointShader,r,this._scene,this._fbo),this._renderer.render(this._gradientShader,null,this._gradientScene,n)}updateData(t){this.addPoint(t[0],t[1],t[2])}_clearFBO(){this.device.clear({color:[0,0,0,0],depth:1,framebuffer:this._fbo})}clearHeatCache(){}resetData(){this._reset()}updateGradient(){this._initGradient()}clear(){this._reset(),super.clear()}_reset(){this.pointCount=0,this.bufferIndex=0,this.offsetIndex=0,this.intensityIndex=0}initContext(){this._initData(),this._initMesh(),this._initGradient();const t={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},e={blend:{enable:!0,func:{dst:1,src:1}},depth:{enable:!1},viewport:t};this._pointShader=new i.MeshShader({name:"heatmap-point",vert:"attribute vec2 aPosition;\nattribute vec2 aOffset;\nattribute float aIntensity;\nvarying vec2 off, dim;\nvarying float vIntensity;\nuniform mat4 projViewModelMatrix;\nuniform float zoomScale;\nvoid main() {\n    off = aOffset;\n    dim = abs(off);\n    vec2 pos = aPosition.xy + zoomScale * off;\n    vIntensity = aIntensity / 255.0;\n    gl_Position = projViewModelMatrix * vec4(pos, 0.0, 1.0);\n}",frag:"precision highp int;\nprecision highp float;\nvarying vec2 off, dim;\nvarying float vIntensity;\nvoid main() {\n    float falloff = (1.0 - smoothstep(0.0, 1.0, length(off / dim)));\n    float intensity = falloff * vIntensity;\n    gl_FragColor = vec4(intensity);\n}",wgslVert:"struct VertexInput {\n    @location($i) aPosition: vec2f,\n    @location($i) aOffset: vec2f,\n    @location($i) aIntensity: f32,\n};\nstruct VertexOutput {\n    @builtin(position) Position: vec4f,\n    @location($o) off: vec2f,\n    @location($o) dim: vec2f,\n    @location($o) vIntensity: f32,\n};\nstruct GlobalUniforms {\n    zoomScale: f32,\n};\nstruct MyAppUniforms {\n    projViewModelMatrix: mat4x4f,\n};\n@group(0) @binding($b) var<uniform> globalUniforms: GlobalUniforms;\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n    var vertexOutput: VertexOutput;\n    var off = vec2f(vertexInput.aOffset);\n    vertexOutput.off = off;\n    vertexOutput.dim = abs(vec2f(vertexInput.aOffset));\n    let pos = vertexInput.aPosition.xy + globalUniforms.zoomScale * off;\n    vertexOutput.vIntensity = f32(vertexInput.aIntensity) / 255.0;\n    vertexOutput.Position = uniforms.projViewModelMatrix * vec4f(pos, 0.0, 1.0);\n    return vertexOutput;\n}",wgslFrag:"struct FragmentInput {\n    @location($i) off: vec2f,\n    @location($i) dim: vec2f,\n    @location($i) vIntensity: f32,\n};\n@fragment\nfn main(fragmentInput: FragmentInput) -> @location(0) vec4f {\n    let falloff = 1.0 - smoothstep(0.0, 1.0, length(fragmentInput.off / fragmentInput.dim));\n    let intensity = falloff * fragmentInput.vIntensity;\n    return vec4f(intensity, intensity, intensity, intensity);\n}",extraCommandProps:e}),this._gradientShader=new i.MeshShader({name:"heatmap-gradient",vert:"attribute vec4 aPosition;\nvarying vec2 texcoord;\nvoid main() {\n    texcoord = aPosition.xy * 0.5 + 0.5;\n    gl_Position = aPosition;\n}",frag:"precision highp int;\nprecision highp float;\nuniform sampler2D source;\nvarying vec2 texcoord;\nfloat linstep(float low, float high, float value) {\n    return clamp((value-low)/(high-low), 0.0, 1.0);\n}\nfloat fade(float low, float high, float value) {\n    float mid = (low+high)*0.5;\n    float range = (high-low)*0.5;\n    float x = 1.0 - clamp(abs(mid-value)/range, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, x);\n}\nvec3 getColor(float intensity) {\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 cyan = vec3(0.0, 1.0, 1.0);\n    vec3 green = vec3(0.0, 1.0, 0.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 color = (\n    fade(-0.25, 0.25, intensity)*blue +\n    fade(0.0, 0.5, intensity)*cyan +\n    fade(0.25, 0.75, intensity)*green +\n    fade(0.5, 1.0, intensity)*yellow +\n    smoothstep(0.75, 1.0, intensity)*red\n    );\n    return color;\n}\nvec4 alphaFun(vec3 color, float intensity) {\n    float alpha = smoothstep(0.00000000, 1.00000000, intensity);\n    return vec4(color*alpha, alpha);\n}\nvoid main() {\n    vec4 value = texture2D(source, texcoord);\n    float intensity = smoothstep(0.0, 1.0, value.r);\n    vec3 color = getColor(intensity);\n    gl_FragColor = alphaFun(color, intensity);\n}",wgslVert:"struct VertexInput {\n    @location($i) aPosition: vec4i,\n};\nstruct VertexOutput {\n    @builtin(position) Position: vec4f,\n    @location($o) texcoord: vec2f,\n};\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n    var vertexOutput: VertexOutput;\n    var position = vec4f(vertexInput.aPosition);\n    vertexOutput.texcoord = vec2f(position.x * 0.5 + 0.5, -position.y * 0.5 + 0.5);\n    vertexOutput.Position = position;\n    return vertexOutput;\n}",wgslFrag:"struct FragmentInput {\n    @location($i) texcoord: vec2f,\n};\n@group(0) @binding($b) var source: texture_2d<f32>;\n@group(0) @binding($b) var sourceSampler: sampler;\nfn linstep(low: f32, high: f32, value: f32) -> f32 {\n    return clamp((value - low) / (high - low), 0.0, 1.0);\n}\nfn fade(low: f32, high: f32, value: f32) -> f32 {\n    let mid = (low + high) * 0.5;\n    let range = (high - low) * 0.5;\n    let x = 1.0 - clamp(abs(mid - value) / range, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, x);\n}\nfn getColor(intensity: f32) -> vec3f {\n    let blue = vec3f(0.0, 0.0, 1.0);\n    let cyan = vec3f(0.0, 1.0, 1.0);\n    let green = vec3f(0.0, 1.0, 0.0);\n    let yellow = vec3f(1.0, 1.0, 0.0);\n    let red = vec3f(1.0, 0.0, 0.0);\n    let color = (\n        fade(-0.25, 0.25, intensity) * blue +\n        fade(0.0, 0.5, intensity) * cyan +\n        fade(0.25, 0.75, intensity) * green +\n        fade(0.5, 1.0, intensity) * yellow +\n        smoothstep(0.75, 1.0, intensity) * red\n    );\n    return color;\n}\nfn alphaFun(color: vec3f, intensity: f32) -> vec4f {\n    let alpha = smoothstep(0.00000000, 1.00000000, intensity);\n    return vec4f(color * alpha, alpha);\n}\n@fragment\nfn main(fragmentInput: FragmentInput) -> @location(0) vec4f {\n    let value = textureSample(source, sourceSampler, fragmentInput.texcoord);\n    let intensity = smoothstep(0.0, 1.0, value.r);\n    let color = getColor(intensity);\n    let fragColor = alphaFun(color, intensity);\n    return fragColor;\n}",extraCommandProps:{blend:{enable:!0,func:{src:1,dst:"one minus src alpha"}},depth:{enable:!1},viewport:t}})}_initData(){this.bufferIndex=0,this.offsetIndex=0,this.intensityIndex=0,this.pointCount=0,this.maxPointCount=10240;const{positionBufferData:t,offsetBufferData:e,intensityBufferData:i}=this._initBuffers();this.positionBufferData=t,this.offsetBufferData=e,this.intensityBufferData=i}_initBuffers(){const t=this.getMap().getRenderer().isWebGPU();return{positionBufferData:new Float32Array(2*this.maxPointCount*6),offsetBufferData:new Float32Array(2*this.maxPointCount*6),intensityBufferData:t?new Float32Array(1*this.maxPointCount*6):new Uint8Array(1*this.maxPointCount*6)}}_initMesh(){this._renderer=new i.Renderer(this.device),this._geometry=new i.Geometry({aPosition:this.positionBufferData,aOffset:this.offsetBufferData,aIntensity:this.intensityBufferData},null,6*this.pointCount,{positionSize:2}),this._geometry.generateBuffers(this.device),this._mesh=new i.Mesh(this._geometry),this._scene=new i.Scene([this._mesh]);const t=this.canvas,e=this.device.texture({type:"float16",min:"nearest",mag:"nearest",width:t.width,height:t.height});this._fbo=this.device.framebuffer({width:t.width,height:t.height,colors:[e],colorFormat:"rgba",depthStencil:!1});const n=new Int8Array([-1,-1,0,1,1,-1,0,1,-1,1,0,1,-1,1,0,1,1,-1,0,1,1,1,0,1]);this._gradientGeometry=new i.Geometry({aPosition:n},null,0,{positionSize:4}),this._gradientGeometry.generateBuffers(this.device),this._gradientMesh=new i.Mesh(this._gradientGeometry),this._gradientScene=new i.Scene([this._gradientMesh])}_initGradient(){const t=function(t){const e=document.createElement("canvas"),i=e.getContext("2d",{willReadFrequently:!0}),n=i.createLinearGradient(0,0,0,256);e.width=256,e.height=1;for(const e in t)n.addColorStop(+e,t[e]);return i.fillStyle=n,i.fillRect(0,0,1,256),{data:i.getImageData(0,0,1,256).data,width:e.width,height:e.height}}(this.layer.options.gradient);this._gradientTexture?this._gradientTexture.update?this._gradientTexture.update(t):this._gradientTexture(t):this._gradientTexture=this.device.texture(t),this._gradientMesh.setUniform("source",this._fbo)}addVertex(t,e,i,n,a){const o=this.getMap(),h=o.getGLRes();s.set(t,e);const f=o.coordToPointAtRes(s,h,r);t=f.x,e=f.y,this.positionBufferData[this.bufferIndex++]=t,this.positionBufferData[this.bufferIndex++]=e,this.offsetBufferData[this.offsetIndex++]=i,this.offsetBufferData[this.offsetIndex++]=n,this.intensityBufferData[this.intensityIndex++]=255*a}addPoint(t,e,i){const n=this.layer.options.radius||25;null==i&&(i=.2);i/=this.layer.options.max||1,this._check();const a=n;return this.addVertex(t,e,-a,-a,i),this.addVertex(t,e,+a,-a,i),this.addVertex(t,e,-a,+a,i),this.addVertex(t,e,-a,+a,i),this.addVertex(t,e,+a,-a,i),this.addVertex(t,e,+a,+a,i),this.pointCount+=1}_check(){if(this.pointCount>=this.maxPointCount-1){this.maxPointCount+=10240;const{positionBufferData:t,offsetBufferData:e,intensityBufferData:i}=this._initBuffers();for(let i=0;i<this.bufferIndex;i++)t[i]=this.positionBufferData[i],e[i]=this.offsetBufferData[i];for(let t=0;t<this.intensityIndex;t++)i[t]=this.intensityBufferData[t];this.positionBufferData=t,this.offsetBufferData=e,this.intensityBufferData=i,this._updateGeometryData()}}_updateGeometryData(){this._geometry.updateData("aPosition",this.positionBufferData),this._geometry.updateData("aOffset",this.offsetBufferData),this._geometry.updateData("aIntensity",this.intensityBufferData)}onResize(t){if(this._fbo&&this.canvas){const t=this.canvas;this._fbo.width===t.width&&this._fbo.height===t.height||this._fbo.resize(t.width,t.height)}super.onResize(t)}onRemove(){this._reset(),this._pointShader&&(this._pointShader.dispose(),delete this._pointShader),this._gradientShader&&(this._gradientShader.dispose(),delete this._gradientShader),this._gradientTexture&&(this._gradientTexture.destroy(),delete this._gradientTexture),this._mesh&&(this._mesh.dispose(),delete this._mesh),this._geometry&&(this._geometry.dispose(),delete this._geometry),this._fbo&&(this._fbo.destroy(),delete this._fbo),this._gradientMesh&&(this._gradientMesh.dispose(),delete this._gradientMesh),this._gradientGeometry&&(this._gradientGeometry.dispose(),delete this._gradientGeometry),delete this.positionBufferData,delete this.offsetBufferData,delete this.intensityBufferData,delete this._renderer,delete this._scene,delete this._gradientScene,super.onRemove()}};o.registerRenderer("gl",n),o.registerRenderer("gpu",n)}export{o as HeatLayer};"undefined"!=typeof console&&console.log("maptalks.heatmap v0.7.0");
//# sourceMappingURL=maptalks.heatmap.es.js.map
